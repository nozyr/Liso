/******************************************************************************* echo_server.c                                                               **                                                                             ** Description: This file contains the C source code for an echo server.  The  **              server runs on a hard-coded port and simply write back anything**              server runs on a hard-coded port and simply write back anything**              server runs on a hard-coded port and simply write back anything**              sent to it by connected clients. The code is based on the      **              starter code provided and the I/O multiplex code on 15213      **                                                                             ** Authors: Yurui Zhou <yuruiz@ece.cmu.edu                                     **                                                                             ********************************************************************************/#include "liso.h"#define USAGE "Usage: %s <HTTP port> <HTTPS port> <logFile> <lockFile> <wwwFolder> <CGIScript> <key> <cert>\n"int main(int argc, char *argv[]) {    int http_port, https_port;    char *log_file, *lock_file, *www_folder, *cgi_path, *private_key, *cert_key;    int http_listen_socket, https_listen_socket, http_client_sock, https_client_socket;    SSL_CTX* ssl_context = NULL;    socklen_t conn_size;    struct sockaddr_in http_addr, https_addr, cli_addr;    static pool conn_pool;    if (argc != 9) {        printf(USAGE, argv[0]);        return EXIT_FAILURE;    }    http_port = atoi(argv[1]);    https_port = atoi(argv[2]);    log_file = argv[3];    lock_file = argv[4];    www_folder = argv[5];    cgi_path = argv[6];    private_key = argv[7];    cert_key = argv[8];//    daemonize(lock_file);    initIO(lock_file, www_folder, cgi_path);    loginit(log_file);    logging("-------------------Server Start------------------\n");    if (sslinit(ssl_context, private_key, cert_key) == -1){        return EXIT_FAILURE;    }    if ((http_listen_socket = open_port(http_port, &http_addr)) == -1) {        SSL_CTX_free(ssl_context);        return EXIT_FAILURE;    }    if ((https_listen_socket = open_port(https_port, &https_addr)) == -1) {        close_socket(https_listen_socket);        SSL_CTX_free(ssl_context);        return EXIT_FAILURE;    }    init_pool(http_listen_socket, https_listen_socket, &conn_pool);    do {        conn_pool.ready_set = conn_pool.read_set;        conn_pool.nconn = select(conn_pool.maxfd + 1, &conn_pool.ready_set, NULL, NULL, NULL);        conn_size = sizeof(cli_addr);        if (FD_ISSET(http_listen_socket, &conn_pool.ready_set)) {            logging("Adding new http connection\n");            if((http_client_sock = accept(http_listen_socket, (struct sockaddr *) &cli_addr, &conn_size)) == -1){                logging("Error accepting http connection.\n");                break;            }            add_conn(http_client_sock, &conn_pool);        }        if(FD_ISSET(https_listen_socket, &conn_pool.ready_set)) {            logging("Adding new https connection\n");            if((https_client_socket = accept(http_listen_socket, (struct sockaddr *) &cli_addr, &conn_size)) == -1){                logging("Error accepting https connection.\n");                break;            }            add_ssl(https_client_socket, &conn_pool, ssl_context);        }        conn_handle(&conn_pool);    } while (conn_pool.nconn >= 0);    SSL_CTX_free(ssl_context);    close_socket(http_listen_socket);    close_socket(https_listen_socket);    return EXIT_SUCCESS;}