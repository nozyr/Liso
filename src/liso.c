/******************************************************************************* echo_server.c                                                               **                                                                             ** Description: This file contains the C source code for an echo server.  The  **              server runs on a hard-coded port and simply write back anything**              server runs on a hard-coded port and simply write back anything**              server runs on a hard-coded port and simply write back anything**              sent to it by connected clients. The code is based on the      **              starter code provided and the I/O multiplex code on 15213      **                                                                             ** Authors: Yurui Zhou <yuruiz@ece.cmu.edu                                     **                                                                             ********************************************************************************/#include "liso.h"#include "conn.h"#define USAGE "Usage: %s <HTTP port> <HTTPS port> <logFile> <lockFile> <wwwFolder> <CGIScript> <key> <cert>\n"int main(int argc, char *argv[]) {    int http_port, https_port;    char *log_file, *lock_file, *www_folder, *cgi_path, *private_key, *cert_key;    int listen_sock, client_sock;    socklen_t conn_size;    struct sockaddr_in host_addr, cli_addr;    static pool conn_pool;    if (argc != 9) {        printf(USAGE, argv[0]);        return EXIT_FAILURE;    }    http_port = atoi(argv[1]);    https_port = atoi(argv[2]);    log_file = argv[3];    lock_file = argv[4];    www_folder = argv[5];    cgi_path = argv[6];    private_key = argv[7];    cert_key = argv[8];//    daemonize(lock_file);,    initIO(lock_file, www_folder, cgi_path);    loginit(log_file);    logging("-------------------Server Start------------------\n");    if ((listen_sock = socket(PF_INET, SOCK_STREAM, 0)) == -1) {        logging("Failed creating socket.\n");        return EXIT_FAILURE;    }    logging("Listen socket created successfully!\n");    host_addr.sin_family = AF_INET;    host_addr.sin_port = htons(http_port);    host_addr.sin_addr.s_addr = INADDR_ANY;    if (bind(listen_sock, (struct sockaddr *) &host_addr, sizeof(host_addr))) {        close_socket(listen_sock);        logging("Failed binding socket.\n");        return EXIT_FAILURE;    }    logging("Listen socket binded successfully\n");    if (listen(listen_sock, 5)) {        close_socket(listen_sock);        logging("Error listening on socket.\n");        return EXIT_FAILURE;    }    logging("Start listening at port %d.\n", listen_sock);    init_pool(listen_sock, &conn_pool);    do {        conn_pool.ready_set = conn_pool.read_set;        conn_pool.nconn = select(conn_pool.maxfd + 1, &conn_pool.ready_set, NULL, NULL, NULL);//        logging("the waiting connection number is %d\n", conn_pool.nconn);        conn_size = sizeof(cli_addr);        if (FD_ISSET(listen_sock, &conn_pool.ready_set)) {            logging("Adding new connection\n");            client_sock = accept(listen_sock, (struct sockaddr *) &cli_addr, &conn_size);            add_conn(client_sock, &conn_pool);        }        conn_handle(&conn_pool);    } while (conn_pool.nconn >= 0);    close_socket(listen_sock);    return EXIT_SUCCESS;}